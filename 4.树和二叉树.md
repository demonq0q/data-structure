# 树和二叉树的基本概念

- 树结构是一类重要的**非线性数据结构**。树是以分支关系定义的层次结构。

## 树的定义

- 树（Tree）是 $n(n\ge 0)$ 个结点的有限集，当 n=0 时为空树，否则为非空树。

- 非空树 T 满足以下两个条件
1. 有且仅有一个称之为根（Root）的结点；
2. 除根结点以外的其余结点可分为 $m(m>0)$ 个互不相交的有限集 $T_1,T_2,...,T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

- 树的结构定义是一个递归的定义，即在树的定义中又用到树的定义。一般来说，分等级的分类方案都可用层次结构来表示，都可由一个树结构来表示。

## 树的基本术语
1. 结点：树中的一个独立单元。包含一个数据元素及若干指向其子树的分支。
2. 结点的度：结点拥有的子树称为结点的度。
3. 树的度：树的度是树内各结点度的最大值。
4. 叶子：度为0的结点称为叶子或终端结点。
5. 非终端结点：度不为0的结点称为非终端结点或分支结点，除根结点之外，非终端结点也称内部结点。
6. 双亲和孩子：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲或父亲。
7. 兄弟：同一个双亲的孩子之间互称兄弟。
8. 祖先：从根到该结点所经分支上的所有结点称为该结点的祖先。
9. 子孙：以某结点为根的子树中的任一结点都称为该结点的子树。
10. 层次：结点的层次从根开始，根为第一层，根的孩子为第二层，以此类推。
11. 堂兄弟：双亲在同一层的结点互为堂兄弟。
12. 树的深度：树中结点的最大层次称为树的深度或高度
13. 有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
14. 森林：是 $m(m\ge 0)$ 棵互不相关的树的集合。对树中每个结点而言，其子树的集合即为森林。

## 二叉树的定义

- 二叉树（Binary Tree）是 $n(n\ge 0))$ 个结点所构成的集合，它为空树（n=0）或非空树，对于非空树 T 满足两个条件：
1. 有且仅有一个称之为根的结点；
2. 除根结点以外的其余结点分为两个互不相关的左子树 $T_1$ 和右子树 $T_2$，且 $T_1$ 和 $T_2$ 本身又都是二叉树。

### 二叉树的基本形态

- 二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵树分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。

- 二叉树有5种基本形态

![二叉树的5种基本形态](https://img-blog.csdnimg.cn/20200330145137194.png?t_70)

### 二叉树的特殊形态

- 满二叉树和完全二叉树（近似满二叉树）是二叉树的两种特殊形态

![满二叉树和完全二叉树](https://img-blog.csdnimg.cn/20200330145319114.png?t_70)

> 在完全二叉树中，若某个结点没有左儿子，则它一定没有右儿子。

> 什么是二叉树？简述二叉树的五种基本形态。
>
> 二叉树是每个结点最多有两个子树的有序树。通常子树的根被称作“左子树”和“右子树”。
>
> 二叉树也是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：（1）空二叉树；（2）只有一个根结点的二叉树；（3）只有左子树的二叉树；（4）只有右子树的二叉树；（5）左、右子树均非空的二叉树。

## 二叉树的性质
1. 在二叉树的第 i 层上最多有 $2^{i-1}$ 个结点（$i\ge 1$），如二叉树的第三层上最多有4个结点。
2. 深度为 k 的二叉树最多有 $2^k-1$ 个结点（$k\ge 1$） ，入深度为3的二叉树最多有7个结点。
3. 对任何一棵二叉树，如果其叶子结点数为 $n_0$，度为2的结点数为 $n_2$，则 $n_0=n_2+1$
4. 具有 n 个结点的完全二叉树的深度为 $\lfloor \log_2n \rfloor+1$（$\lfloor \log_2n \rfloor$ 表示大于 $\log_2n$的最大整数），如具有9个结点的完全二叉树的深度为 $\lfloor \log_2 9 \rfloor+1=4$ 
5. 对一棵树有 n 个结点的完全二叉树（深度为 $\lfloor \log_2n \rfloor+1$）的结点按层次编号（从第1层到第 $\lfloor \log_2n \rfloor+1$ 层，每层从左到右），从一个结点的编号就可推知其父、左、右儿子、兄弟等结点的编号。

- 对于结点 i 有如下关系
1. 仅当 i=1 时，结点 i 为根结点；若 i>1，则结点 i 的双亲结点为 $\lfloor i/2 \rfloor$
2. 若 2i>n，则结点 i 无左孩子，即结点 i 为叶子结点；若 $2i\le n$，则结点 i 的左孩子的结点 2i
3. 若 2i+1>n，则结点 i 无右孩子；若 $2i+1\le n$，则结点 i 的右孩子是结点 2i+1
4. 当 i 为奇数且不为1时，结点 i 的左兄弟是结点 i-1，否则结点 i 无左兄弟
5. 当 i 为偶数且不为 n 时，结点 i 的右兄弟是结点 i+1，否则结点 i 无右兄弟

# 树和二叉树的存储结构

## 二叉树的存储额结构

### 顺序存储结构

- 将二叉树的所有结点按照一定的线性次序存储到连续的存储单元中，使得结点在这个序列中的相互位置能反映出结点之间的逻辑关系。

#### 完全二叉树的顺序存储结构

- 在一棵具有 n 个结点的完全二叉树中，从树根起，自下而上，逐层从左到右给所有结点编号，就能得到一个反映整个二叉树结构的线性序列，其中，每个结点的编号就作为结点的名称。

- 将数组的下标作为结点名称（编号），就可以将二叉树中所有结点的标号存储在一个一维数组中。

#### 一般二叉树的顺序存储结构

- 为了能用结点在数组中的位置来表示结点之间的逻辑关系，必须按近似满二叉树的形式来存储树中的结点。

### 链式存储结构

- 由一个数据元素和分别指向其左。右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：**数据域**和**左、右指针域**。链表的头指针指向二叉树的根结点。在含有 n 个结点的二叉链表中有 n+1 个空链域

- 二叉链表类型定义
```cpp
typedef struct BiTNode
{
    TElemType data;                     // 结点数据域
    struct BiTNode * lchild, * rchild;  // 左右孩子指针
} BiTNode, * BiTree;
```

## 树的存储结构

- 树由多种形式的存储结构来表示，常用的表示方法有**双亲表示法、孩子表示法、孩子兄弟表示法**

### 双亲表示法

- 双亲表示法以一组连续的存储单元存储树的结点。每个结点除了数据域 data 外，还附设一个 parent 域，用于指示其双亲结点的位置。由于根没有双亲，所有其 parent 域存储的是 -1。

- data是数据域，parent是指针域

![](https://img-blog.csdnimg.cn/20200122102412342.png) 

![](https://img-blog.csdnimg.cn/20200122102435419.png)

### 孩子表示法

- 对树的每个结点建立一个儿子结点表。由于各结点的儿子结点数目多少不一，所以常用链表老来实现儿子结点表。将这些结点及相应的孩子链表的头指针存放在一个顺序结构。

![](https://img-blog.csdnimg.cn/20200325133212116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0h1YmVyeXhpYW8=,size_16,color_FFFFFF,t_70#pic_center)


### 孩子兄弟表示法

- 又称为**二叉树表示法**或**二叉链表表示法**，即以二叉链表作为树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为 firstchild 和 nextsibling

![](https://img-blog.csdnimg.cn/20200122121504359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg5NTAyNg==,size_16,color_FFFFFF,t_70)

# 遍历二叉树和线索二叉树

## 遍历二叉树

### 遍历二叉树算法描述

- 遍历二叉树是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。

- 遍历的定义（若二叉树为空，则空操作，否则：）
1. 先序遍历：访问根节点，先序遍历左子树，先序遍历右子树
2. 中序遍历：中序遍历左子树，访问根节点，中序遍历右子树
3. 后序遍历：后续遍历左子树，后序遍历右子树，访问根节点

- 中序遍历的递归算法

```cpp
void InOrderTraverse(BiTree T)
{
    if(T)                            // 若二叉树非空
    {
        InOrderTraverse(T->lchild);  // 中序遍历左子树
        cout << T->data;             // 访问根节点
        InOrderTraverse(T->rchild);  // 中序遍历右子树
    }
}
```

### 根据遍历序列确定二叉树

- 由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。

#### 根据先序序列和中序序列确定二叉树

1. 二叉树的先序遍历是先访问根节点，其次再按先序遍历方式遍历根结点的左子树，最后按先序遍历方式遍历根结点的右子树。先序序列中，第一个结点一定是二叉树的根结点。
2. 中序序列是先遍历左子树，然后访问根结点，最后遍历右子树。根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。
3. 在先序序列中，左子序列的第一个结点是左子树的根结点，有子序列的第一个结点是右子树的根结点。
4. 左子树和右子树的根结点又可以分别把左子序列和有子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵二叉树。

#### 根据后序序列和中序序列确定二叉树

1. 在后序序列中，最后一个结点一定是二叉树的根结点。
2. 根结点在中序序列中将中序序列分割成两个子序列，分别为根结点左子树的中序序列和右子树的中序序列。
3. 再在后序序列中找到左右子树的根结点，继续分割中序序列。
4. 如此递归，当倒着取尽后序序列中的结点时，便可得到一棵二叉树

### 二叉树遍历算法的应用

#### 创立二叉树的存储结构——二叉链表

- 设二叉树中结点的元素均为一个单字符。设按先序遍历的顺序建立二叉链表，T 为指向根结点的指针，对于给定的一个字符序列，依次读入字符，从根结点开始，递归创建二叉树。

```cpp
void CreateBiTree(BiTree &T)
{
    // 按先序次序输入二叉树中结点的值（一个字符）
    // 创立二叉链表表示的二叉树 T
    cin >> ch;
    if(ch == '#')
        T = NULL;                 // 递归结束，创建空树
    else                          // 递归创建二叉树
    {
        T = new BiTNode;          // 生成根结点
        T->data = ch;             // 根结点数据域置为ch
        CreateBiTree(T->lchild);  // 递归创建左子树
        CreateBiTree(T->rchild);  // 递归创建右子树
    }
}
```

#### 复制二叉树

- 利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。

```cpp
void Copy(BiTree T, BiTree &NewT)
{                                       // 复制一棵和T完全相同的二叉树
    if(T == NULL)                       // 如果是空树，递归结束
    {
        NewT = NULL;
        return;
    }
    else
    {
        NewT = new BiTNode;
        NewT->data = T->data;
        Copy(T->lchild, NewT->lchild);  // 递归复制左子树
        Copy(T->rchild, NewT->rchild);  // 递归复制右子树
    }
}
```

#### 计算二叉树的深度

- 二叉树的深度为树中结点的最大层次，可以理解为二叉树的深度为左右子树深度的较大者加1

```cpp
int Depth(BiTree T)            // 计算二叉树T的深度
{
    if(T == NULL)             // 如果是空树，深度为0，递归结束
        return 0;
    else
    {
        m = Depth(T->lchild);  // 递归左子树的深度记为m
        n = Depth(T->rchild);  // 递归右子树的深度记为n
        if(m > n)
            return m+1;        // 二叉树的深度为m与n的较大者加1
        else
            return n+1;
    }
}
```

## 线索二叉树

### 线索二叉树的定义

- 用二叉链表实现二叉树时，每个结点只有指向其左、右儿子结点的指针，从任一结点出发只能直接找到该结点的左、右儿子。

- 用二叉链表实现二叉树时，在 n 个结点二叉链表中含有 n+1 个空链域，可以利用这些空链域存放结点的前驱和后继信息。

|lchild|LTag|data|RTag|rchild|
|------|----|----|----|------|

- 左标志 LTag
1. 0：lchild 域指示结点的左孩子
2. 1：lchild 域指示结点的前驱

- 右标志 RTag
1. 0：rchild 域指示结点的右孩子
2. 1：rchild 域指示结点的前驱

```cpp
// 二叉树的二叉线索存储表示
typedef struct BiThrNode
{
    TElemType data;
    struct BiThrNode * lchild, * rchild;  // 左右孩子指针
    int LTag, RTag;                       // 左右标志
} BiThrNode, * BiThrTree;
```

> 以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做**线索链表**，其中指向结点前驱和后继的指针叫作**线索**。加上线索的二叉树称之为**线索二叉树**（Threaded Binary Tree）。对二叉树以某种次序遍历使其变为线索二叉树的过程叫作**线索化**。

### 遍历线索二叉树

- 若需要经常查找结点在所遍历线性序列中的前驱和后继，则应采用线索链表作为存储结构。

# 树和森林

## 树、森林域二叉树的转换

- 树或森林域二叉树之间存在一一对应的关系，这一关系说明任何一棵树或一个森林都能转换为一棵二叉树，任何一棵二叉树也能转换为一个森林或一棵树。

- 树、森林和二叉树的额转换

|树转换为二叉树|森林转换为二叉树|二叉树转换为森林|
|---|---|---|
|（1）将所有兄弟结点用线连起来<br>（2）每个结点只保留与其长子的连线，去掉与其他孩子的连线<br>（3）将水平线沿顺时针旋转45°|（1）将森林中的树转换成二叉树<br>（2）将每棵二叉树的根结点看成兄弟从左至右连在一起<br>（3）将水平线沿顺时针旋转45°|（1）若结点 x 是双亲 y 的左孩子，则把 x 的右孩子、右孩子的右孩子......都与 y 用线连接起来<br>（2）去掉所有双亲到右孩子的连线|

## 树和森林的遍历

### 树的遍历

- 由于树中结点可以有超过两个的子树，无法确定根的访问顺序，因此只有两种次序遍历树的方法
1. 先根（次序）遍历，即若树为非空，先访问树的根结点，然后依次先根遍历根的每棵子树
2. 后根（次序）遍历，即若树为非空，先依次后根遍历每棵子树，然后访问根结点

### 森林的遍历

#### 先序遍历森林

- 若森林非空，则
1. 访问森林中第一棵树的根结点
2. 先序遍历第一棵树的根结点的子树森林
3. 先序遍历除去第一棵树之后剩余的树构成的森林

#### 中序遍历森林

- 若森林非空，则
1. 中序遍历森林中第一棵树的根结点的子树森林
2. 访问森林中第一棵树的根结点
3. 中序遍历除去第一棵树之后剩余的树构成的森林

# 哈夫曼树及其应用

## 哈夫曼树的基本概念

- **哈夫曼树**（Huffman tree）又称最优二叉树，是一类带权路径长度最短的二叉树。

1. **路径**：从树中一个结点到了另一个结点之间的分支构成这两个结点之间的路径
2. **路径长度**：路径上的分支数目称作路径长度
3. **树的路径长度**：从树根到每一结点的路径长度之和
4. **权**：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述
5. **结点的带权路径长度**：从该结点到树根之间的路径长度与结点上权的乘积
6. **树的带权路径长度**：树中所有叶子结点的带权路径长度之和，通常记作 $WPL=\sum^n_{k=1}w_kl_k$
7. **哈夫曼树**：假设有 m 个权值 ${w_1,w_2,...,w_n}$，可以构造一棵含 n 个叶子结点的二叉树，每个叶子结点的权为 $w_i$，则其中带权路径长度 WPL 最小的二叉树称作最优二叉树或哈夫曼树

## 哈夫曼树的构造

### 哈夫曼树的构造过程

1. 根据给定 n 个权值 ${w_1,w_2,...,w_n}$，构造 n 棵只有根结点的二叉树，这 n 棵二叉树构成森林 F
2. 在森林 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，并且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和
3. 在森林 F 中删除这两棵树，同时将新得到的二叉树加入 F 中
4. 重复 2 和 3，直到 F 只含一棵树为止。这棵树便是哈夫曼树

### 哈夫曼算法的实现

|weight|parent|lchild|rchild|
|------|------|------|------|

```cpp
// 哈夫曼树的存储表示
typedef struct
{
    int weight;                  // 结点的权值
    int parent, lchild, rchild;  // 结点的双亲、左孩子、右孩子的下标
} HTNode, * HuffmanTree;         // 动态分配数组存储哈夫曼树
```

> 为了实现方便，数组的 0 号单元不使用，从 1 号单元开始使用，所有数组大小为 2n。将叶子结点集中存储在前面部分：1~n 个位置，而后面的 n-1 个位置存储其余非叶子结点

```cpp
// 构造哈夫曼树
void CreateHuffmanTree(HuffmanTree &HT, int n)  // 构造哈夫曼树HT
{
    if(n <= 1) return;
    m = 2 * n - 1;
    HT = new HTNode[m+1];  // 0号单元未用，所有需要动态分配m+1个单元
    for(i=1; i<=m; ++i)    // 初始化1~m号单元中的双亲、左孩子、右孩子的下标
    {
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }
    for(i = 1; i <= m; ++i)  // 输入前n个单元中叶子结点的权值
        cin >> HT[i].weight;
//--------------------初始化工作结束，下面开始创建哈夫曼树-----------------
    for(i = n+1; i <= m; ++i)  
    {
        // 在HT[k](1<=k<=i-1)中选择两个其双亲域为0且权值最小的结点s1和s2
        Select(HT, i-1, s1, s2);
        // 得到新结点i，从森林中删除s1、s2，将s1和s2的双亲域由0改为i
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;  // s1、s2分别作为i的左右孩子
        // i的权值为左右孩子权值之和
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```

## 哈夫曼编码

### 哈夫曼编码的概念

- 对一棵具有 n 个叶子的哈夫曼树来说，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码

### 哈夫曼编码的性质

1. 哈夫曼编码是前缀编码
2. 哈夫曼编码是最优前缀编码

### 哈夫曼编码的实现

- 先构造出哈夫曼树，依次以叶子结点为出发点，向上回溯至根结点为止。关回溯时走左分支则生成代码0，走右分支则生成代码1。

```cpp
// 哈夫曼编码表的存储表示
typedef char * * HuffmanCode;  // 动态分配数组存储哈夫曼编码表
```

```cpp
// 根据哈夫曼树求哈夫曼编码
void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n)
{
    // 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中
    HC = new char * [n+1];     // 分配存储n个字符编码的编码表空间
    cd = new char[n];          // 分配临时存放每个字符编码的动态数组空间
    cd[n-1] = '\0';            // 编码结束符
    for(i = 1; i <= n; ++i)    // 逐个字符求哈夫曼编码
    {
        start = n-1;           // start开始时指向最后，即编码结束符位置
        c = i;
        f = HT[i].parent;      // 从叶子结点开始向上回溯，直到根结点
        while(f != 0)
        {
            --start;                // 回溯一次start向前指一个位置
            if(HT[f].lchild == c)
                cd[start] = '0';    // 结点c是f的左孩子，则生成代码0
            else
                cd[start] = '1';    // 结点c是f的右孩子，则生成代码1
            c = f;
            f = HT[f].parent;       // 继续向上回溯
        }                           // 求出第i个字符的编码
        HC[i] = new char[n-start];  // 为第i个字符编码分配空间
        strcpy(HC[i], &cd[start]);  // 复制编码从临时空间cd到HC的当前行中
    }
    delete cd;                      // 释放临时空间
}
```

# 二叉排序树和平衡二叉树

## 二叉排序树

- 二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。

### 定义

- 二叉排序树或者一棵空树，或者是具有下列性质的二叉树
1. 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；
2. 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；
3. 它的左、右子树也分别为二叉排序树

> 二叉排序树是递归定义的。由定义得出一个重要性质：**中序遍历一棵二叉排序树时可以得到一个结点值递增的有序序列。

### 插入

1. 若二叉函数为空，则待插入结点作为根结点插入到空树中
2. 若二叉函数为空，则将key与根结点的关键字进行比较

> 若key小于根结点的关键字，则将关键字为key插入左子树
>
> 若key大于根结点的关键字，则将关键字为key插入右子树

### 创建

1. 将二叉排序树T初始化为空树
2. 读入一个关键字为key的结点
3. 如果读入的关键字key不是输入结束标志，则循环执行以下操作

> 将此结点插入二叉排序树T中
>
> 读入一个关键字为key的结点

## 平衡二叉树

- 平衡二叉树或者是空树，或者是具有如下特征的二叉排序树
1. 左子树和右子树的深度之差的绝对值不超过1
2. 左子树和右子树也是平衡二叉树

# 总结

1. 二叉树是一种最常用的树形结构，满二叉树和完全二叉树是两种特殊形态的二叉树
2. 二叉树有顺序存储和链式存储两种存储表示，期中链式存储又称二叉链表，是二叉树常用的存储结构
3. 二叉树的遍历算法是其他运算的基础，根据访问结点的次序不同可得到先序遍历、中序遍历、后序遍历三种遍历算法
4. 哈夫曼树又称最优二叉树，是一类带权路径长度最短的二叉树
5. 哈夫曼树在通信编码技术上有广泛的应用，只要构造了哈夫曼树，按分支情况在左路径上写代码0，右路径上写代码1，然后从根到叶结点路径上的代码序列结束该结点的哈夫曼编码