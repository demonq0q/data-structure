# 线性表的逻辑结构

## 线性表的逻辑定义

- 由 $n(n \ge 0)$ 个数据特性相同的元素构成的有限序列称为**线性表**。线性表中元素的个数 $n(n \ge 0)$ 定义为线性表的长度，n=0 时称为空表。

- 对于非空的线性表或线性结构，其特点是：
1. 存在唯一的一个被称作“第一个”的数据元素；
2. 存在唯一的一个被称作“最后一个”的数据元素；
3. 除第一个数据元素之外，结构中的每个数据元素均只有一个前驱；
4. 除最后一个数据元素之外，结构中的每个数据元素均只有一个后继。
   
   ## 线性表的基本运算
   
   > InitList(&L):构造一个空的线性表L，即表的初始化。
   > ListLength(L):返回L中的数据元素个数，即求表长。
   > GetElem(L, i, &e):用e返回L中第i个数据元素的值（$1 \le i \le ListLength(L)$）。
   > LocateElem(L, e):返回L中第1个值与e相同的元素在L中的位置，若不存在，则返回值为0。
   > ListInsert(&L, i, e):在L中第i个位置之前插入新的数据元素e，L的长度加1。
   > ListDelete(&L, i):删除L中的第i个数据元素，L的长度减1。

# 线性表的顺序存储结构

## 顺序表的定义及地址计算

### 顺序表的定义

- 用一组地址连续的存储单元依次存储线性表的数据元素，也称作线性表的**顺序存储结构**或顺序映像。用顺序存储结构的线性表称为**顺序表**。特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。
  
  ### 地址的计算方法

- 线性表的每个元素只需占用 l 个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储起始位置。则线性表中第 i+1 个数据元素的存储位置 $LOC(a_{i+1})$ 和第 i 个数据元素的存储位置 $LOC(a_i)$ 之间满足的关系：
  $$
  LOC(a_{i+1})=LOC(a_i)+l
  $$

- 一般来说，线性表的第 i 个数据元素 $a_i$ 的存储位置为：
  $$
  LOC(a_i)=LOC(a_i)+(i-1)×l
  $$
  
  ### 顺序表类型定义
- 通常用数组来描述数据结构中的顺序存储结构
```cpp
#define MAXSIZE 100
typedef struct         // 顺便表可能达到的最大长度
{
	ELemType * elem;   // 存储空间的基地址
	int length;        // 当前长度
} SqList;              // 顺序表的结构类型为SqList
```
  
  ## 顺序表的基本操作
  ### 初始化
- 顺序表的初始化操作就是构造一个空的顺序表
1. 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。
2. 将表的当前长度设为0。
   
   ```cpp
Status InitList(SqList &L)
{
	// 构造一个空的顺序表L
	L.elem = new ElemType[MAXSIZE];  // 为顺序表分配一个大小为MAXSIZE的数组空间
	if(!L.elem) eixt(OVERFLOW);      // 存储分配失败退出
	L.length = 0;                    // 空表长度为0
	return OK;
}
   ```
   
   > 动态分配线性表的存储区域可以更有效地利用系统的资源。当不需要该线性表时，可以使用销毁操作及时释放占用的存储空间。

### 取值
- 根据指定的位置序号 i ，获取顺序表中第 i 个数据元素的值
- 顺序存储结构具体随机存取的特点，可以直接通过数组下标定位得到，elem[i-1] 单元存储到 i 个数据元素
1. 判断指定的位置序号 i 值是否合理 $(1 \le i \le L.length)$，若不合理，则返回ERROR。
2. 若 i 值合理，则将第 i 个数据元素 L.elem[i-1] 赋给参数 e，通过  e 返回第 i 个数据元素的传值。
   ```cpp
struct GetElem(SqList L, int i, ElemType &e)
{
	if(i<1 || i>L.length)
		return ERROR;       // 判断i值是否合理，若不合理，则返回ERROR
	e = L.elem[i-1];        // elem[i-1]单元存储到第i个数据元素
	return OK;
}
   ```
   
   > 顺序表取值算法的时间复杂度为 $O(1)$。

### 查找
- 根据指定的元素值 e，查找顺序表中第1个与 e 相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0。
1. 从第一个元素起，依次和 e 相比较，若找到与 e 相等的元素 L.elem[i]，则查找成功，返回该元素的序号 i+1。
2. 若查遍整个顺序表都没有找到，则查找失败，返回0。
   
   ```cpp
int LocateElem(SqList L, ElemType e)
{
	// 在顺序表L中查找值为e的数据元素，返回其序号
	for(i = 0; i < L.length; i++)
		if(L.elem[i] == e) 
			return i+1;                 // 查找成功，返回i+1
	return 0;                           // 查找失败，返回0
}
   ```
   > 顺序表按值查找算法的平均时间复杂度为 $O(n)$。
   
   ### 插入
- 在表的第 $i(1\le i\le n+1)$ 个位置插入一个新的数据元素 e，使长度为 n 的线性表变成长度为 n+1 的线性表
- 数据元素之间的逻辑关系发生了变化
1. 判断插入位置 i 是否合法，若不合法则返回 ERROR。
2. 判断顺序表的存储空间是否已满，若满则返回 ERROR。
3. 将第 n 个至第 i 个位置的元素依次向后移动一个位置，空出第 i 个位置（ i=n+1 时无须移动）。
4. 将要插入的新元素 e 放入第 i 个位置。
5. 表长加1。
   ```cpp
Status ListInsert(SqList &L, int i, ElemType e)
{
	// 在顺序表L中第i个位置插入新的元素e，i值合法返回是1<=i<=L.length+1
	if(i<1 || (i>L.length+1))
		return ERROR;                        // i值不合法
	if(L.length == MAXSIZE)
	   return ERROR;                        // 存储空间已满，不能插入
	for(j = L.length-1; j >= i-1; j--)
	   L.elem[j+1] = L.elem[j];             // 插入位置及之后的元素后移
	L.elem[i-1] = e;                         // 将新元素e放入第i个位置
	++L.length;                              // 表长加1
	return OK;
}
   ```
   
   > 顺序表插入算法的平均时间复杂度为 $O(n)$。

### 删除
- 将表的第 $i(1\le i\le n)$ 个元素删去，将长度为 n 的线性表变成长度为 n-1 的线性表。数据元素之间的逻辑关系发生了变化，为了在存储结构上反映这个变化，同样需要移动元素
   ```cpp
Status ListDlete(SqList &L, int i)
{
	// 在顺序表L中删除第i个元素，i值的合法返回是1<=i<=L.length
	if(i<1 || (i>L.length)) return ERROR;  // i值不合法
	for(j = i; j <= L.length; j++)
	   L.elem[j-1] = L.elem[i];           // 被删除元素之后元素前移
	   --L.length;                        // 表长减1
	return OK;
}
   ```
   > 顺序表删除算法的平均时间复杂度为 $O(n)$。

# 线性表的链式存储结构
## 单链表
### 单链表的定义与表示
- 单链表的定义：n 个结点链接成一个链表即为线性表的链式存储结构。线性表的链式存储结构的特点是：<u>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</u>单链表的结点包括两个域：**数据域**用于存储数据元素信息；**指针域**用于存储直接后继的存储位置，指针域中的存储的信息称作指针或链，<u>单链表的每个结点中只包含一个指针域</u>。
     
     ![](https://img-blog.csdnimg.cn/20210207165334490.png#pic_center)
     
     > 单链表是由表头指针唯一确定的，因此单链表可以用头指针的名字来命名。若头指针名是 L，则简称该链表为表 L。

 - 头结点：有时为了方便对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，此时头指针指向的结点就是头结点。
     ![](https://img-blog.csdnimg.cn/20210207165354972.png#pic_center)
     
     > 头指针、头结点、首元结点的区别：
     > 
     > 1. 首元结点是指链表中存储第一个数据元素 $a_i$ 的结点。
     > 2. 头结点是在首元结点之前附设的一个结点 ，其指针域指向首元结点。头结点的数据域可以存储与数据元素类型相同的其他附加信息，也可不存储任何信息。
     > 3. 头指针是指向链表中第一个结点的指针。若链表没有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为首元结点。

-  单链表的类型定义
   
   ```cpp
typedef struct LNode
{
	ElemType data;        // 结点的数据域
	struct LNode * next;  // 结点的指针域
} LNode, * LinkList;      // LinkList为指向结构体LNode的指针类型
   ```
### 单链表的基本操作
#### 初始化
- 单链表的初始化操作就是构造一个空表
1. 生成新结点作为头结点，用头指针 L 指向头结点。
2. 头结点的指针域置空。
```cpp
struct InitList(LinkList &L)
{
	// 构造一个空的单链表L
	L = new LNode;   // 生成新结点作为头结点，用头指针L指向头结点
	L->next = NULL;  // 头结点的指针置空
	return OK;
}
```
#### 取值
- 和顺序表不同，链表中逻辑相邻的结点并没有存储在物理相邻的单元中，给定的结点位置序号 i，只能从链表的首元结点出发，顺着链域 next 逐个结点向下访问
```cpp
Status GetElem(LinkList L, int i, ElemType &e)
{
	// 在带头结点的单链表L中用e返回第i个数据元素的值
	p = L->next;
	j = 1;                // 初始化，p指向首元结点，计数器j初值赋为i
	while(p && j>i)
	{
		p = p->next;      // p指向下一个结点
		++j;              // 计数器j相应加1
	}
	if(!p || j>i)
		return ERROR;     // i值不合法 i>n 或 i<=0
	e = p->data;          // 取第i个结点的数据域
	return OK;
}
```
> 单链表取值算法的平均时间复杂度为 $O(n)$。

#### 按值查找
```cpp
LNode * LocateElem(LinkList L, ElemType e)
{
	// 在带头结点的单链表L中查找值为e的元素
	p = L->next;              // 初始化，p指向首元结点 
	while(p && p->data != e)  // 顺链域向后扫描
		p = p->next;          // p指向下一个结点
	return p;                 // 查找成功，返回
}
```
> 算法的执行时间与待查找的值e相关，其平均时间复杂度为 $O(n)$。

#### 插入
- 设要在单链表的两个元素 a 和 b 之间插入一个数据元素 x，p 为其单链表存储结构中指向结点 a 的指针，s 为指向结点 x 的指针，则语句描述即为：s->next = p->next; p->next = s;
- 将值为 e 的新结点插入到表的第 i 个结点的位置上，即插入到结点 $a_{i-1}$ 与 $a_i$ 之间
```cpp
Status LinkInsert(LinkList &L, int i, ElemType e)
{
	// 在带头结点的单链表L中第i个位置插入值为e的新结点
	p = L;
	j = 0;
	while(p && (j < i-1))
	{
		p = p->next;       // 查找第i-1个结点，p指向该结点
		++j;               // i>n+1 或者 i<1
	}
	if(!p || j > i-1)
		return ERROR;      // i>n+1 或者 i<1
	s = new LNode;         // 生成新结点 *s
	s->data = e;           // 将结点 *s 的数据域置为 e
	s->next = p->next;     // 将结点 *s 的指针域指向 a_i
	p->next = s;           // 将结点 *p 的指针域指向结点 *s
	return OK;
}
```
> 时间复杂度为 $O(n)$。

#### 删除
- 要删除单链表中指定位置的元素，插入元素一样，首先应该找到该位置的前驱结点。
- 删除元素 b 时，先找到其前驱结点 a。设 p 为指向结点 a 的指针，则修改指针的语句为：p->next = p->next->next;
```cpp
Status ListDelete(LinkList &L, int i)
{
	// 在带头结点的单链表L中，删除第i个元素
	p = L;
	j = 0;
	while((p->next) && (j <i-1 ))  // 查找第 i-1 个结点，p指向该结点
	{
		p = p->next;
		++j;
	}
	if(!(p->next) || (j > i-1))
		return ERROR;             // 当 i>n 或 i<1 时，删除位置不合理
	q = p->next;                  // 临时保存被删结点的地址以备释放
	p->next = q->next;            // 改变删除结点前驱结点的指针域
	delete q;                     // 释放删除结点的空间
	return OK;
}
```
> 类似于插入算法，删除算法主要时间耗费在查找操作上，时间复杂度为 $O(n)$。

#### 创建单链表
- 前插法：通过新结点逐个插入链表的头部（头结点之后）来创建链表。
- 后插法：通过将新结点逐个插入到链表的尾部来创建链表。
## 循环链表
### 单循环链表
- （表中的最后一个结点的指针为空指针）将最后一个结点的指针域指向头结点，使整个链表形成一个环，这首尾相接的链表就称为**循环链表**。<u>从任意一个结点出发都可以找到表中其他结点</u>。
- 单循环链表和单链表的差别仅在于：当链表遍历时，判别当前指针 p 是否指向表尾结点的终止条件不同。在单链表中，判别条件为 p != NULL 或 p->next != NULL; 在单循环链表中，判别条件为 p != L 或 p->next != L 。
### 双向链表
- 在链表的每个结点中设置两个指针，一个指向后继结点，另一个指向前驱结点，形成双向链表，简称为双链表。
## 顺序表和链表的比较
### 空间性能的比较
1. 存储空间的分配：当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构。
2. 存储密度的大小：当线性表的长度变化不大，易于事先确定其大小时，宜采用顺序表作为存储结构。
### 时间性能比较
1. 存取元素的效率：若线性表的主要操作是和元素位置紧密相关的取值操作，很少做插入或删除时，宜采用顺序表作为存储结构。
2. 插入和删除操作的效率：对于频繁进行插入或删除的线性表，宜采用链表作为存储结构。
# 顺序表的应用
## 线性表的合并
```cpp
void MergeList(List &LA, List LB)
{
	// 将所有在线性表LB中但不在LA中的数据元素插入LA中
	m = ListLength(LA);
	n = ListLength(LB);              // 求线性表长度
	for(i = 1; i <= n; i++)
	{
		GetElem(LB, i ,e);           // 取LB中第i个数据元素赋给e
		if(! LocateElem(LA, e))      // LA不存在和e相同的数据元素
			ListInsert(LA, ++m, e);  // 将e插在LA的最后
	}
}
```
## 有序表的合并
- 若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非递减或非递增有序排列，则称该线性表为**有序表**。
```cpp
void MergeList_Sq(Sq_list LA, SqList LB, SqList &LC)
{
	LC.length = LA.length + LB.length;  // 新表长度为待合并两表的长度之和
	LC.elem = new ElemType[LC.length];  // 为合并后的新表分配一个数组空间
	pc = LC.elem;                       // 指针pc指向新表的第一个元素
	pa = LA.elem;
	pb = LB.elem;                       // 指针pa和pb的初值分别指向两个表的第一个元素
	pa_last = LA.elem + LA.length - 1;  // 指针pa_last指向LA的最后一个元素
	pb_last = LB.elem + LB.length - 1;  // 指针pb_last指向LA的最后一个元素
	while((pa <= pa_last) && (pb <= pb_last))
	{
		if(*pa <= *pb)
			*pc++ = *pa++;              // 依次取两表中值较小的结点插入LC的最后
		else
			*pc++ = *pb++;
	}
	while(pa <= pa_last)
		*pc++ = *pa++;                  // LB到达表尾
	while(pb <= pb_last)
		*pc++ = *pb++;                  // LA到达表尾
}
```
> 时间复杂度为 $O(m+n)$，空间复杂度为 $O(m+n)$。

## 链式有序表的合并
- 设3个指针 pa、pb 和 pc，其中 pa 和 pb 分别指向 LA 和 LB 中当前待比较插入的结点，而 pc 指向 LC 中当前最后一个结点（LC的表头结点设为 LA 的表头结点）。
```cpp
void MergeList_L(LinkList &LA, LinkList &LB, LinkList &LC)
{
	pa = LA->next;
	pb = LB->next;           // pa和pb的初值分别指向两个表的第一个结点
	LC = LA;                 // 用LA的头结点作为LC的头结点
	pc = LC;                 // pc的初值指向LC头结点
	while(pa && pb)
	{
		// LA和LB均为到达表尾，依次取两表中值较小的结点插入到LC的最后
		if(pa->data <= pb->data)  // 取pa所指结点
		{
			pc->next = pa;        // 将pa所指结点链接到pc所指结点之后
			pc = pa;              // pc指向pa
			pa = pa->next;        // pa指向下一个结点
		}
		else                      // 取pb所指结点
		{
			pc->next = pb;        // 将pb所指结点链接到pc所指结点之后
			pc = pb;              // pc指向pb
			pb = pb->next;        // pb指向下一个结点
		}
	}
	pc->next = pa ? pa : pb;      // 将非空表的剩余部分插入到pc所指结点之后
	delete LB;                    // 释放LB的头结点
}
```
> 空间复杂度为 $O(1)$。

# 总结
1. 线性表的逻辑结构特性是指数据元素之间存在着线性表关系，在计算机中表示这种关系的两类不同的存储结构是顺序存储结构（顺序表）和链式存储结构（链表）。
2. 对于顺序表，元素存储的相邻位置反映出其逻辑上的线性关系，可借助数组来表示。给定数组的下标，便可以存取相应的元素，可称为随机存取结构。而对于链表，是依靠指针来反映其线性表逻辑关系的，链表结点的存储都要从头指针开始，顺链而行，所有不属于随机存取结构，可称之为顺序存取结构。
3. 对于链表，除了常用的单链表外，还有循环链表和双向链表两种不同形式的链表。